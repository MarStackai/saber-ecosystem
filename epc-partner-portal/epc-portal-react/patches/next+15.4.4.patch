diff --git a/node_modules/next/dist/build/swc/index.js b/node_modules/next/dist/build/swc/index.js
index d9c95f2..bc8e858 100644
--- a/node_modules/next/dist/build/swc/index.js
+++ b/node_modules/next/dist/build/swc/index.js
@@ -256,11 +256,16 @@ async function loadBindings(useWasmBinary = false) {
         }
         let attempts = [];
         const disableWasmFallback = process.env.NEXT_DISABLE_SWC_WASM;
+        const forceWasm = [
+            "1",
+            "true",
+            "yes"
+        ].includes(String(process.env.NEXT_FORCE_WASM_BINARY || "").toLowerCase());
         const unsupportedPlatform = triples.some((triple)=>!!(triple == null ? void 0 : triple.raw) && knownDefaultWasmFallbackTriples.includes(triple.raw));
         const isWebContainer = process.versions.webcontainer;
         // Normal execution relies on the param `useWasmBinary` flag to load, but
         // in certain cases where there isn't a native binary we always load wasm fallback first.
-        const shouldLoadWasmFallbackFirst = !disableWasmFallback && useWasmBinary || unsupportedPlatform || isWebContainer;
+        const shouldLoadWasmFallbackFirst = forceWasm || !disableWasmFallback && useWasmBinary || unsupportedPlatform || isWebContainer;
         if (!unsupportedPlatform && useWasmBinary) {
             _log.warn(`experimental.useWasmBinary is not an option for supported platform ${PlatformName}/${ArchName} and will be ignored.`);
         }
@@ -270,6 +275,10 @@ async function loadBindings(useWasmBinary = false) {
             if (fallbackBindings) {
                 return resolve(fallbackBindings);
             }
+            if (forceWasm) {
+                logLoadFailure(attempts, true);
+                throw new Error('Failed to load wasm bindings while NEXT_FORCE_WASM_BINARY is enabled.');
+            }
         }
         // Trickle down loading `fallback` bindings:
         //
@@ -279,7 +288,7 @@ async function loadBindings(useWasmBinary = false) {
         // download corresponding target triple and load it. This won't be triggered if native bindings are failed to load
         // with other reasons than `ERR_MODULE_NOT_FOUND`.
         // - Lastly, falls back to wasm binding where possible.
-        try {
+        if (!forceWasm) try {
             return resolve(loadNative());
         } catch (a) {
             if (Array.isArray(a) && a.every((m)=>m.includes('it was not installed'))) {
@@ -291,7 +300,7 @@ async function loadBindings(useWasmBinary = false) {
             attempts = attempts.concat(a);
         }
         // For these platforms we already tried to load wasm and failed, skip reattempt
-        if (!shouldLoadWasmFallbackFirst && !disableWasmFallback) {
+        if (!shouldLoadWasmFallbackFirst && !disableWasmFallback && !forceWasm) {
             const fallbackBindings = await tryLoadWasmWithFallback(attempts);
             if (fallbackBindings) {
                 return resolve(fallbackBindings);
@@ -834,12 +843,13 @@ async function loadWasmRawBindings(importPath = '') {
             '@next/swc-wasm-web'
         ]){
             try {
-                let pkgPath = pkg;
+                let importedRawBindings;
                 if (importPath) {
-                    // the import path must be exact when not in node_modules
-                    pkgPath = _path.default.join(importPath, pkg, 'wasm.js');
+                    const pkgPath = _path.default.join(importPath, pkg, 'wasm.js');
+                    importedRawBindings = await import((0, _url.pathToFileURL)(pkgPath).toString());
+                } else {
+                    importedRawBindings = await import(pkg);
                 }
-                const importedRawBindings = await import((0, _url.pathToFileURL)(pkgPath).toString());
                 let rawBindings;
                 if (pkg === '@next/swc-wasm-web') {
                     // https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html
